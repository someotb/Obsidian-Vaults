Представим, что у нас есть две структуры, содержащие информация о расстоянии - в шагах и в метрах. Программа из этого примера выполнит сложение двух структур и отобразит результат на экране.

![[Pasted image 20240421121826.png]]![[Pasted image 20240421121836.png]]
![[Pasted image 20240421121842.png]]Думаю тут объяснения излишне, все абсолютно понятно.

Рассмотрим еще один пример: сложение двух комплексных чисел с использованием структуры и передачей структуры функции.

Комплексные числа - это математическая концепция, которая включает в себя вещественную часть и мнимую часть. Вещественная часть - это обычные числа, которые мы используем в повседневной жизни, такие как 1, 2, 3 и т. д. Мнимая часть - это число, умноженное на мнимую единицу \(i\), которая определена как \(\sqrt{-1}\). Таким образом, комплексное число имеет форму \(a + bi\), где \(a\) - вещественная часть, а \(b\) - мнимая часть.

Комплексные числа широко используются в математике, физике, инженерии и других областях. Они обеспечивают удобный способ работы с корнями уравнений, электрическими схемами, теорией вероятностей и многими другими математическими концепциями.

Данная программа похожа на предыдущую, но в ней сложение будет выполнять функция add(). В нее мы будем передавать две структуры и она же будет вычислять результат. Код программы:

![[Pasted image 20240421124102.png]]![[Pasted image 20240421124113.png]]

В этом фрагменте кода `typedef` используется для создания синонима `complexNumber` для структуры `struct complex`. Это делается для того, чтобы использовать более краткий и понятный синтаксис при объявлении переменных типа `complexNumber`, а не `struct complex`.

Без использования `typedef` объявление переменных типа `struct complex` выглядело бы так:

```cpp
struct complex nl, n2, temporaryNumber;
```

А с использованием `typedef`:

```cpp
complexNumber nl, n2, temporaryNumber;
```

Это делает код более читаемым и удобным для использования.

Также нужно обратить свое внимание на эту строку:

```cpp
signOfImag = (temporaryNumber.imag > 0) ? '+' : '-'
```

Это тернарный оператор в языке C++, который представляет собой условное выражение. В этом конкретном случае, выражение оценивается следующим образом:

1. Если `temporaryNumber.imag > 0` истинно, т.е. если мнимая часть `temporaryNumber` положительна, то результатом выражения будет `'+'`.
2. В противном случае, если `temporaryNumber.imag > 0` ложно, т.е. мнимая часть `temporaryNumber` отрицательна или равна нулю, результатом будет `'-'`.

Таким образом, результат этого выражения присваивается переменной `signOfImag`. Если мнимая часть положительна, `signOfImag` будет содержать символ `+`, в противном случае он будет содержать символ `-`. Это часто используется для форматирования вывода, чтобы отображать знак мнимой части числа.

*Усложним задачу.* Напишем программу, вычисляющую разницу между двумя периодами времени. Для этого определим структуру `TIME` (содержащую информацию о часах, минутах, секундах) и пользовательскую функцию `differenceBetweenTimePeriod()`, которой мы передадим три структуры. Первые две содержат начальное и конченое время соответственно, третья - результат, то есть разницу между этими двумя структурами.

В этой программе мы попросим пользователя ввести два периода времени, мы сохраняем их в переменные типа TIME - это наша структура, содержащая информацию о времени. Далее, функция `differenceBetweenTimePeriod()` вычисляет разницу. Обратите внимание поскольку мы используем технику вызова по ссылке, то данная функция ничего не возвращает в функцию `main()` - результат сразу записывается в переменную diff.

Я попытался сделать программу сам и вот что у меня вышло:
```cpp
#include <iostream>

using namespace std;

struct TIME{
    int hours;
    int minutes;
    int seconds;
};

void differenceBetweenTimePeriod(TIME t1, TIME t2, TIME rest){
    if(t1.hours > t2.hours){
       rest.hours = t1.hours - t2.hours;
       rest.minutes = t1.minutes - t2.minutes;
       rest.seconds = t1.seconds - t2.seconds;
    }
    else{
        rest.hours = t2.hours - t1.hours;
        rest.minutes = t2.minutes - t1.minutes;
        rest.seconds = t2.seconds - t1.seconds;
    }
}

 int main(){
    TIME t1, t2, diff;
    
    // Время первого события
    cout << "Введите время первого события: " << endl;
    cout << "Введите часы: ";
    cin >> t1.hours;
    cout << "Введите минуты: ";
    cin >> t1.minutes;
    cout << "Введите секнды: ";
    cin >> t1.seconds;
    
    // Время второго события
    cout << "Введите время второго события: " << endl;
    cout << "Введите часы: ";
    cin >> t2.hours;
    cout << "Введите минуты: ";
    cin >> t2.minutes;
    cout << "Введите секнды: ";
    cin >> t2.seconds;

    differenceBetweenTimePeriod(t1, t2, diff);

    cout << "Разница времени между первым и вторым событием: " << endl;
    cout << "Часы: " << diff.hours << endl;
    cout << "Минуты: " << diff.minutes << endl;
    cout << "Секунды: " << diff.seconds << endl;
 }
```

И у меня не выводится результат, часы, минуты и секунды переменной `diff` равны 0. В коде приведена функция `differenceBetweenTimePeriod`, которая должна вычислять разницу между двумя моментами времени `t1` и `t2` и сохранять результат в структуру `rest`. 

Однако, в данной реализации есть несколько проблем:

1. Разница во времени может быть отрицательной, что приведет к некорректному результату в случае, если время `t1` меньше времени `t2`.
2. Если разница в минутах или секундах отрицательная, то необходимо скорректировать значения, чтобы они находились в пределах допустимых значений.
3. Функция не возвращает результат.

Вот исправленная версия функции:

```cpp
void differenceBetweenTimePeriod(TIME t1, TIME t2, TIME &diff){
    int totalSeconds1 = t1.hours * 3600 + t1.minutes * 60 + t1.seconds;
    int totalSeconds2 = t2.hours * 3600 + t2.minutes * 60 + t2.seconds;
    int differenceInSeconds = abs(totalSeconds2 - totalSeconds1);
    
    diff.hours = differenceInSeconds / 3600;
    differenceInSeconds %= 3600;
    diff.minutes = differenceInSeconds / 60;
    differenceInSeconds %= 60;
    diff.seconds = differenceInSeconds;
}
```

Здесь используется побитовое усечение для приведения времени к корректному формату. Также я добавил передачу параметра `diff` по ссылке (`&diff`), чтобы изменения, внесенные внутри функции, отражались на переменной `diff` в функции `main`.

1. **Побитовое усечение (Modulus Operator, %):**
   - В выражении `differenceInSeconds %= 3600;` используется оператор побитового усечения (%), который возвращает остаток от деления левого операнда на правый операнд. В данном случае, это применяется для приведения общего количества секунд к значению от 0 до 3599, так как в часе 3600 секунд.
   - Например, если `differenceInSeconds` равно 3700, то после применения оператора `%` к 3600, останется 100 секунд (3700 % 3600 = 100).

2. **Параметр функции по ссылке (`&diff`):**
   - В исходной функции `differenceBetweenTimePeriod`, параметр `diff` передается по значению, что означает, что внутри функции работается с копией переданной структуры, а не с оригиналом. Изменения, внесенные в `diff`, не отразятся на переменной `diff` в функции `main`.
   - Чтобы обойти это ограничение и позволить функции изменять переданный аргумент, используется передача по ссылке (`&`). Теперь, если мы изменяем `diff` внутри функции, эти изменения будут отражены на переменной `diff` в функции `main`.

Пример:

```cpp
void someFunction(int x) {
    x = 10; // Изменение значения локальной копии переменной x
}

void someFunctionByReference(int &x) {
    x = 10; // Изменение значения переменной x, переданной по ссылке
}

int main() {
    int value = 5;
    
    someFunction(value);
    cout << value << endl; // Выведет 5, значение переменной value не изменилось

    someFunctionByReference(value);
    cout << value << endl; // Выведет 10, значение переменной value изменилось
    return 0;
}
```

Таким образом, использование передачи параметра по ссылке (`&`) позволяет функции изменять значение переменной, переданной в качестве аргумента, что является необходимым в данном случае, чтобы функция могла корректно изменить значения структуры `diff`.

Конечно в этой программе еще не хватает проверки на правильность входных данных, но сейчас не об этом, так что продолжим.

