*Разница между различным представлением строк в С++*

Строки - неотъемлемая часть любой программы. В этой части мы рассмотрим ряд примеров, демонстрирующих обработку строк в программах.

Чтобы получить размер строки (количества символов), хранимой строковым объектом (класса `string`) используйте функцию `size()`:

Напишем программу, подсчитывающую сколько раз искомый символ встречается в заранее определенной строке. Программа в цикле "проходится" по строке и подсчитывает частоту символа, то есть считает, сколько раз в строке встречается искомый символ. Код программы приведен в листинге 9.1.
![[Pasted image 20240419155200.png]]
![[Pasted image 20240419155208.png]]

В языке С используется иной стиль строки. Типа string нет и строка представляет собой массив символов, то есть элементов типа char. Все строки в С заканчиваются знаком `\0`, означающим конец строки. Пример работы с такой строкой приведен ниже:
![[Pasted image 20240419172344.png]]

*Подсчет цифр и пробелов*
Задача проста: дан текст и нужно вычислить:
- Общее количество символов
- Количество пробелов в тексте 
- Количество цифр в тексте
Теперь нужно написать довольно простую статическую программу. Далее в этой книге мы напишем аналог приложения wc в Linux - полноценную программу для подсчета слов. А пока небольшая разминка.
![[Pasted image 20240419172812.png]]
![[Pasted image 20240419172820.png]]

Здесь используется `cin.getline()` так можно использовать функцию `getline()` для типов `char`, но если тебе жирная жопа захотелось использовать эту функцию для типа `string` то тебе придется писать так:
```
string str;

getline(cin, str);
```
Да, такова жизнь, здесь функция вывода cin, становится аргументом другой функции, и такое нахуй бывает. Вот почему так происходит:
	Это связано с тем, что `getline()` является функцией, а не оператором ввода-вывода, поэтому требуется явное указание, откуда брать данные.
	
Функция `getline()` ожидает два аргумента:
1. Ссылка на объект `istream`, из которого нужно считывать данные (например, `cin`).
2. Ссылка на объект типа `string`, в который нужно сохранить считанные данные.

А также количество символов можно было бы узнать с помощью функции `strlen()`, но как говорит автор, раз у нас все равно есть цикл, то мы подсчитывали количество в нем, хотя я бы на его месте показал как работает эта функция, обновлять знания это всегда хорошо, но у этого его решения есть и плюсы, хоть он об этом и не сказал, но он частично оптимизировал программу тем что засунул все в один цикл, и не стал использовать лишние функции.

*next dude, Удаляем все символы в строке, кроме цифровых*

В данном примере мы напишем программу, удаляющую из строки все символы, кроме цифровых. Такая задача часто встречается при очистке строк, содержащих номера телефонов, номера банковских карт и др.

Работает программа так:
- Пользователь вводит строку, которую мы записываем в переменную line
- В цикле мы проверяем, является ли символ цифровым.
- Если нет, то все символы после него, включая нулевой символ, смещаются на 1 позицию влево.
![[Pasted image 20240419180107.png]]
![[Pasted image 20240419180131.png]]


==Вот важна инфа:==
![[Pasted image 20240419180236.png]]

В случае с `char` определить длину строки можно с помощью функции `strlen`  и вроде если мне не изменяет память то с помощью `sizeof`, но для этого еще понадобится знать тип данных. Так-с продолжим, в случае с типом `string` используется функция `size()`.

Вот код который выполняет почти тоже самое:
```cpp
#include <iostream>
#include <string>

using namespace std;

string onlynumbers(string str) {
    string str_new;

    for (int i = 0; i < str.size(); i++) {
        if (isdigit(str[i])) { // Проверяем, является ли символ цифрой
            str_new += str[i]; // Если да, добавляем его к новой строке
        }
    }
    
    return str_new;
}

int main() {
    string str_old, str_new;
    cout << "Введите строку: ";
    getline(cin, str_old);

    str_new = onlynumbers(str_old);
    cout << str_new << endl;

    return 0;
}
```

Этот код будет удалять все символы, кроме цифр, из введенной строки и выводить оставшиеся цифры. Функция `isdigit()` используется для проверки, является ли символ цифрой.

ПХАХАХА, автор ебанулся, ладно. Давайте напишем программу определяющую длину строки, без использования готовых функций.

Вместо массива символов нам нужно использовать тип `string`, чтобы была возможность использовать функция `getline()`. Функция `getline()` принимает два параметра - поток ввода (`cin` - стандартный ввод) и название переменной, в которую будет записана строка. Если мы будем использовать оператор `>>`, то строка будет введена до первого пробельного символа.
Функция `getline()` читает строку со всеми пробельными символами. Далее алгоритм программы тот же - мы "проходимся" по всем символам строки(пока не будет встречен конец строки) и увеличиваем счетчик `i`.
![[Pasted image 20240419230838.png]]

*Объединение нескольких строк в одну* 

Для конкатенации (объединения) двух строк обычно используются функция `strcat()`. Но мы напишем программу, показывающую, как устроена эта функция - чтобы вы знали, как можно объединить две строки без ее использования.(гениально)
![[Pasted image 20240419231054.png]]![[Pasted image 20240419231105.png]]

Если мы используем строки в стиле С (то есть массив символов), то код будет несколько иным:
![[Pasted image 20240419231151.png]] На этот раз мы использовали функцию strcat(), чтобы продемонстрировать ее работу.

*Копирование двух строк*

При использовании объекта типа string для копирования строк вы можете использовать просто оператор присваивания `=`. При использовании строк в стиле С лучшим решением является использование функции strcpy. Рассмотрим оба варианта:
![[Pasted image 20240419235645.png]]

И в стиле С:
![[Pasted image 20240419235653.png]]
![[Pasted image 20240419235700.png]]

*Оператор сравнения строк*

Напишем программу, которая отсортирует в лексикографическом порядке массив строк. Для сравнения строк мы используем функцию `strcmp()`, а функция `strcpy()` используется для копирования строки в переменную `temp` в процессе сортировки. Будем работать со строками, как с массивами символов.

Алгоритм прост: во время перебора двухмерного массива строк `str` мы сравниваем две строки. Если первая строка больше(лексикографически), чем вторая, то функция `strcmp()` возвращает 0. При этом мы меняем местами эти две строки и так до тех пор, пока строки не будут распложены в лексикографическом порядке.

```cpp
#include <iostream>

using namespace std;

int main()
{
string str[10], temp;

cout << "Введите 10 слов: " << endl;
for(int i = 0; i < 10; i++){
	getline(cin, str[i]);
}

for(int i = 0; i < 9; i++){
	for(int j = i+1; j < 10; j++){
		if(str[i] > str[j])
			{
			temp = str[i];
			str[i] = str[j];
			str[j] = temp;
			}	
		}
	}

cout << "Сортируем: " << endl;

for(int i = 0; i < 10; i++)
	{
	cout << str[i] << endl;
	}

return 0;
}
```
Да конечно программа работает, но сперва я подумал, что она не работает потому что, на этапе ввода строки, я ввел слово с пробелом, ведь думал что раз у нас ввод осуществляется при помощи `getline()` то будет и так работать, но видимо нет, ну либо я ебанулся ведь уже поздновато и я что-то подустал, пойти спать что-ли, кста сейчас ![[Pasted image 20240420001604.png]], надеюсь у будущего меня уже есть девушка, bro ты все сможешь, просто ебашь как ты это умеешь, я в тебя верю!!

А это оказывается конец главы про Строки, ух это было классно, заспидранил такую немаленькую главу за один день, просто Бог. 

А мы летим дальше в Структуры и объединения в С++(но это уже завтра)