Для объявления класса используется ключевое слово `class`:
```cpp
class имя_класса {
	закрытые методы (функция) и переменные класса
public:
	открытые методы и переменные класса
} [список объектов класса];
```

Обрати внимание на то что после закрывающей круглой скобки стоит ";".

Также обратите внимание, что список объектов - необязательная часть. Вы можете объявить список объектов позже в программе, когда вам это будет нужно.

Функция(методы) и переменные, объявленные внутри объявления класса, называют членами(members) класса. Чтобы не возникло путаницы, функции класса часто называют методами класса

Все члены класса, объявленные после служебного слова `public`, являются публичными(общедоступными) - их можно использовать, как и другим членам класса, так и в любой другой части программы, в которой находится этот класс.

*Практический пример создания класса на С++*

Сейчас мы разработаем собственный класс. Чтобы пример имел практическую ценность, мы разработает класс стека, который можно использовать для хранения символов.

```cpp
#include <iostrem>
using namespace std;

const int SIZE = 26;

class stack {
	char stck[SIZE];
	int tos;
public:
	void init();
	void push(char ch);
	char pop();
};

void stack::init()
{
	tos = 0;
}

void stack::push(char ch)
{
	if (tos == SIZE) {
		cout << "Стек полон!" << endl;
		return;
	}
	stck[tos] = ch;
	tos++
}

char stack::pop(){
	if(tos==0){
		cout << "Стек пуст!" << endl;
		return 0;
	}
	tos--;
	return stck[tos];
}

int main()
{
	stack s1,s2;
	int i;

	s1.init();
	s2.init();

	s1.push('a');
	s2.push('b');
	s1.push('c');
	s2.push('d');
	s1.push('e');
	s2.push('f');

	for (int i = 0; i < 3; i++) cout << s1.pop() << " ";
	cout << endl;
	for (int i = 0; i < 3; i++) cout << s2.pop() << " ";
	cout << endl;
}
```

Этот код на C++ реализует простую структуру данных - стек. Давайте разберем его по частям:

1. Включение библиотеки `iostream`:
   ```cpp
   #include <iostream>
   using namespace std;
   ```
   Эта строка подключает стандартную библиотеку ввода-вывода C++.

2. Объявление константы `SIZE`:
   ```cpp
   const int SIZE = 26;
   ```
   Эта строка объявляет константу `SIZE` и устанавливает ее равной 26.

3. Определение класса `stack`:
   ```cpp
   class stack {
       char stck[SIZE];
       int tos;
   public:
       void init();
       void push(char ch);
       char pop();
   };
   ```
   Здесь определяется класс `stack`, который имеет члены `stck`, `tos` и методы `init()`, `push()` и `pop()`. `stck` представляет массив символов, который используется для хранения элементов стека. `tos` (Top Of Stack) - это индекс вершины стека.

4. Определение метода `init()`:
   ```cpp
   void stack::init() {
       tos = 0;
   }
   ```
   Метод `init()` инициализирует вершину стека (`tos`) как ноль.

5. Определение метода `push()`:
   ```cpp
   void stack::push(char ch) {
       if (tos == SIZE) {
           cout << "Стек полон!" << endl;
           return;
       }
       stck[tos] = ch;
       tos++;
   }
   ```
   Метод `push()` добавляет элемент в стек. Если стек уже полон (количество элементов равно `SIZE`), выводится сообщение об ошибке. В противном случае, элемент добавляется в стек, и вершина стека инкрементируется.

6. Определение метода `pop()`:
   ```cpp
   char stack::pop() {
       if (tos == 0) {
           cout << "Стек пуст!" << endl;
           return 0;
       }
       tos--;
       return stck[tos];
   }
   ```
   Метод `pop()` удаляет элемент из вершины стека и возвращает его. Если стек пуст, выводится сообщение об ошибке, и возвращается нулевой символ.

7. Функция `main()`:
   ```cpp
   int main() {
       stack s1, s2;

       s1.init();
       s2.init();

       s1.push('a');
       s2.push('b');
       s1.push('c');
       s2.push('d');
       s1.push('e');
       s2.push('f');

       for (int i = 0; i < 3; i++) cout << s1.pop() << " ";
       cout << endl;
       for (int i = 0; i < 3; i++) cout << s2.pop() << " ";
       cout << endl;

       return 0;
   }
   ```
   В функции `main()` создаются два объекта класса `stack` - `s1` и `s2`. Затем для каждого объекта вызывается метод `init()` для инициализации стеков. Далее в стеки добавляются элементы с помощью метода `push()`. После этого происходит последовательное извлечение элементов из стеков с помощью метода `pop()`, и результаты выводятся на экран.

Таким образом, данный код реализует структуру данных стек с помощью класса `stack`, предоставляя методы для инициализации, добавления элемента и извлечения элемента.

Обрати внимание на ТО, почему мы обращаемся к методам класса, именно так как в программе, вот полное объяснение:

В C++, когда вы определяете метод класса вне его определения (например, когда вы определяете методы класса вне его объявления), вы должны указывать имя класса, к которому этот метод принадлежит, с использованием оператора разрешения области видимости `::`. Это делается для явного указания того, к какому классу относится данный метод.

Таким образом, вот как это работает:

- `void stack::push`: это синтаксис для определения метода `push` класса `stack`. Здесь `stack::push` говорит компилятору, что метод `push` относится к классу `stack`.

- `void push`: такой синтаксис не будет работать, потому что он не дает информации о том, к какому классу относится метод `push`. Компилятор не сможет найти определение метода без этой информации.

Использование оператора разрешения области видимости `::` позволяет избежать конфликтов имен и упрощает понимание кода, указывая явно, к какому классу относится данный метод.