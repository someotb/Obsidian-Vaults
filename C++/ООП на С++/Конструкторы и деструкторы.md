После создания объектов типа stack в [[Структура класса|предыдущей]] теме, мы вызываем функцию `init()` для каждого объекта, которая выполняет инициализацию стека, а именно устанавливает `tos` в 0. Если этого не сделать, значение `tos` не будет определено и дальше все зависит от компилятора. Некоторые же ничего не будут делать, *тогда ошибка времени выполнения гарантирована.*

Было бы хорошо, чтобы функция инициализации вызывалась автоматически. Ведь вы можете легко забыть ее вызвать или вызвать, но не для всех объектов - для `s1`, например, вызовите, а для `s2` - забудете. Да и вообще это неудобно - вызывать функцию инициализации вручную. 

Разработчики языка С++ также так думают, поэтому они разработали конструкторы и деструкторы. Конструктор класса вызывает всяяяяяяяяяякий раз при создании объекта этого класса. Код нашей функции `init` идеально было бы поместить в конструктор класса - тогда вы никогда не забудете инициализировать объект.

Функция-деструктор вызывается при удалении объекта. Код этой функции обычно содержит освобождение выделенной памяти. закрытие соединения с базой данных или Интернет-сервером, закрытие файла и т.д.

Наша программа ничего такого не делает, поэтому в деструкторе прямой необходимости нет.

Функция-конструктор называется так же, как и класс. Объявляется он так:
```cpp
stack::stack()
{
}
```

Имя деструктора предварительно тильдой ~:
```cpp
stack::~stack()
{
}
```

Код программы, использующей конструкторы и деструкторы, будет приведен ниже. Обратите внимание: теперь `init()` можно не вызывать, но саму функцию `init()` я оставил в классе - вдруг понадобится в процессе работы со стеком выполнить заново инициализацию. Инициализация стека осуществляется автоматически с помощью конструктора. Деструктор просто выводит сообщение о том, что он работает - для демонстрации его возможностей(в нашей простой программе в нем нет необходимости).

```cpp
#include <iostream>

using namespace std;

const int SIZE = 26;

class stack {
	char stck[SIZE];
	int tos;
public:
	stack();
	~stack();
	void init();
	void push(char ch);
	char pop();
};

stack::stack()
{
	cout << "Инициализируем стек\n";
	tos = 0;
}

stack::~stack()
{
cout << "Работает деструктор...\n";
}

void stack::init()
{
	tos = 0;
}

void stack::push(char ch)
{
	if (tos == SIZE) {
		cout << "Стек полон!" << endl;
		return;
	}
	stck[tos] = ch;
	tos++;
}

char stack::pop() {
	if (tos == 0) {
		cout << "Стек пуст" << endl;
		return 0;
	}
	tos--;
	return stck[tos];
}

int main()
{
	stack s1, s2;
	int i;

	s1.push('a');
	s2.push('b');
	s1.push('c');
	s2.push('d');
	s1.push('e');
	s2.push('f');

	for (int i =0; i < 3; i++) cout << s1.pop() << " ";
	cout << endl;
	for (int i = 0; i < 3; i++) cout << s2.pop() << " ";
	cout << endl;
}
```

ДА уж, гений на авторе, вот нравится человеку лишние строчки кода писать, может быть конечно так надо делать, но я пока что до этого не дорос. Но хочу отметить, что его код легко читается.

Эта программа реализует класс `stack` для работы со стеком символов. Вот краткое описание ее работы:

1. Класс `stack` имеет члены данных `stck` и `tos`. `stck` является массивом символов, представляющим стек, а `tos` (Top of Stack) - индексом вершины стека.
   
2. Конструктор `stack::stack()` инициализирует стек, устанавливая `tos` в 0.

3. Деструктор `stack::~stack()` просто выводит сообщение о том, что он работает, и необходим для освобождения ресурсов (в данном случае ресурсы не выделяются явно, но это общепринятая практика).

4. Метод `stack::init()` сбрасывает вершину стека `tos` в 0, позволяя использовать стек снова.

5. Метод `stack::push(char ch)` добавляет символ `ch` в стек, если стек не заполнен.

6. Метод `stack::pop()` удаляет и возвращает верхний элемент стека, если стек не пуст.

7. В функции `main()` создаются два объекта класса `stack`, `s1` и `s2`.

8. С помощью метода `push()` добавляются элементы в каждый из стеков.

9. Затем с помощью метода `pop()` извлекаются и выводятся элементы из каждого стека.

У нашей программы есть недостаток. Она выводит строки `Initializing stack` и `Destructor is working`, но при этом непонятно, какой стек инициализируется и какой разрушается.

Конструкторы могут принимать параметры. Это свойство конструкторов мы будем использовать для идентификации стеков. Мы добавим еще один член -`stackID` типа `int`, затем добавим параметр `id` к нашему конструктору:

```cpp
stack::stack(int id)
{
	stackID = id;
	cout << "Initializing stack" << stackID << endl;
	tos = 0;
}
```

Конструктор устанавливает ID стека и выводит информацию об этом. Аналогично, деструктор будет выглядеть вот так:

```cpp
stack::~stack()
{
	cout << "Деструктор стека №" << stackID << "выполняется...\n";
}
```

Инициализация объектов типа `stack` будет выглядеть так:
```cpp
stack s1(1), s2(2);
```

Вот полный код:

```cpp
#include <iostream>

using namespace std;

const int SIZE = 26;

class stack {
	char stck[SIZE];
	int tos;
	int stackID;
public:
	stack(int id);
	~stack();
	void init();
	void push(char ch);
	char pop();
};

stack::stack(int id)
{
	stackID = id;
	cout << "Initializing stack" << stackID << endl;
	tos = 0;
}

stack::~stack()
{
	cout << "Деструктор стека №" << stackID << "выполняется...\n";
}

void stack::init()
{
	tos = 0;
}

void stack::push(char ch)
{
	if (tos == SIZE) {
		cout << "Стек полон!" << endl;
		return;
	}
	stck[tos] = ch;
	tos++;
}

char stack::pop() {
	if (tos == 0) {
		cout << "Стек пуст" << endl;
		return 0;
	}
	tos--;
	return stck[tos];
}

int main()
{
	stack s1(1), s2(2);
	int i;

	s1.push('a');
	s2.push('b');
	s1.push('c');
	s2.push('d');
	s1.push('e');
	s2.push('f');

	for (int i =0; i < 3; i++) cout << s1.pop() << " ";
	cout << endl;
	for (int i = 0; i < 3; i++) cout << s2.pop() << " ";
	cout << endl;
}
```