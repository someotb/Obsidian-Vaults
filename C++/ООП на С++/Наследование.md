==Наследование== - это один из краеугольных принципов ООП. Допустим, есть какой-то базовый класс, функциональность которого вам нужно расширить. Вы создаете производный класс на его базе и вам не нужно повторять в нем функционал базового класса - он будет унаследован.

Наследование описывается так:
```cpp
class  имя_производного_класса: доступ имя_базового_класса {
//
};
```

Здесь доступ - это модификатор доступа, который может быть `public`, `private` или `protected`. Чаще всего используется `public` или `private`. В первом случае все открытые члены базового класса останутся открытыми и в производном классе. Во втором (`private`) все открытые члены базового класса в производном станут закрытыми.

Пример:
```cpp
#include <iostream>
using namespace std;

class parent {
	int x;
public:
	void setx(int n) { x = n; }
	void showx() { cout << x << endl; }
};

class child:public parent {
	int y;
public:
	void sety(int n) { y = n; }
	void showy() { cout << y << endl; }
};

int main() {
	child ob;
	ob.setx(100); // Получаем доступ к члену базового класса
	ob.sety(200); // Получаем доступ к члену производного класса

	ob.showx(); // Получаем доступ к члену базового класса
	ob.showy(); // Получаем доступ к члену производного класса

	return 0;
}
```
![[Pasted image 20240424200909.png]]

Получается, что мы инициализировать переменную типа `child` и спокойно можем пользоваться функциями, которые мы описали в классе `parent`, согласись удобно сучка!

Если мы укажем модификатор доступа `private`, то получим ошибку при обращении к членам базового класса, а именно:

```cpp
ob.setx(100); // Получаем доступ к члену базового класса
ob.sety(200); // Получаем доступ к члену производного класса
```
