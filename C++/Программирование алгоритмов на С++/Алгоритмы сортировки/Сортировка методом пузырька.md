Еще один популярный в программировании метод сортировки - это сортировка пузырьком (bubble sort в англ. литературе).

Алгоритм пузырьковой сортировки считается самым простым, но довольно неэффективным. Его можно использовать разве что для сортировки небольших массивов. Алгоритм считается учебным и практически не применяется вне учебной литературы, вместо него на практике применяются более эффективные алгоритмы сортировки. НО поскольку мы как раз учимся программировать, данный алгоритм - настоящая находка.

Суть алгоритма заключается в следующем. Программа несколько раз проходится по сортируемому массиву. При каждой итерации элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Получается, что элементы как бы выталкиваются вверх, как пузырьки в воде, отсюда и название алгоритма.

Проходы (итерации) по массиву повторяются `N - 1` раз ил до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает - массив отсортирован.

При каждой итерации очередной наибольший элемент массива становится на свое место в конце массива - рядом с предыдущим наибольшим элементом, а наименьший элемент перемещается на одну позицию к началу массива - 'всплывает'.

Думаю, принцип понятен. Осталось все это закодировать. В нашей программе мы создадим функцию `bubble_sort()`,  которой нужно передать массив элементов и его размер. Функция использует два цикла `for` - внутренний и внешний. Внешний проходится от `0` до `size`, а переменная `size` содержит количество элементов в массиве. Во внутреннем цикле функция проходится от `0` до `size - i`. Если `a[j] > a[j+1]`, то элементы `a[j]` и `a[j+1]` меняются местами. Переменная `hold` используется для хранения временного значения при свапе(swap) элементов.

Код:

```cpp
#include <iostream>

using namespace std;

void bubble_sort(int a[], int size);

int main(void) {
	int arr[10] = {10, 2, 4, 1, 6, 5, 8, 7, 3, 9};
	int i = 0;

	cout << "До сортировки:\n";
	for(i = 0; i < 10; i++) cout << arr[i] << " ";
	cout << endl;
	bubble_sort(arr, 10);

	cout << "После:\n";
	for(i = 0; i < 10; i++) cout << arr[i] << " ";
	cout << endl;
	
	return 0;
}

void bubble_sort(int a[], int size) {
	int switched = 1;
	int hold = 0;
	int i = 0;
	int j = 0;

	size -= 1;

	for(i = 0; i < size && switched; i++) {
		switched = 0;
		for(j = 0; j < size - i; j++)
			if(a[j] > a[j+1]) {
				switched = 1;
				hold = a[j];
				a[j] = a[j+1];
				a[j+1] = hold;
			}
	}
}
```

Данный код реализует алгоритм сортировки пузырьком (bubble sort) для массива целых чисел. Давайте разберем его по частям:

1. `void bubble_sort(int a[], int size)`: Это объявление функции `bubble_sort`, которая принимает два аргумента: массив целых чисел `a[]` и его размер `size`. Функция не возвращает значения (возвращаемый тип `void`).

2. `int switched = 1;`: Переменная `switched` устанавливается в `1`, чтобы начать первую итерацию сортировки.

3. `int hold = 0;`: Переменная `hold` используется для временного хранения значения при обмене элементов массива.

4. `int i = 0;`: Индекс переменной цикла для внешнего цикла сортировки.

5. `int j = 0;`: Индекс переменной цикла для внутреннего цикла сортировки.

6. `size -= 1;`: Уменьшает значение `size` на 1, чтобы корректно работать с индексами массива (так как массивы в C++ индексируются с 0).

7. Внешний цикл `for(i = 0; i < size && switched; i++)`: Этот цикл проходит по массиву от начала до конца (за исключением последнего элемента) и выполняет сравнение и обмен элементов. `switched` используется для оптимизации алгоритма: если на предыдущей итерации не произошло ни одного обмена, значит, массив уже отсортирован, и дальнейшие проходы не требуются.

8. Внутренний цикл `for(j = 0; j < size - i; j++)`: Этот цикл выполняет сравнение и обмен соседних элементов массива, чтобы постепенно "всплывать" наибольшие элементы к концу массива.

9. Условие `if(a[j] > a[j+1])`: Проверяет, больше ли текущий элемент массива, чем следующий за ним. Если это так, то элементы меняются местами.

10. Обмен элементов `a[j]` и `a[j+1]`: Значения обмениваются местами с использованием временной переменной `hold`.

Этот процесс повторяется до тех пор, пока массив не будет отсортирован.

==И еще по поводу switched:==
Переменная `switched` используется для оптимизации алгоритма пузырьковой сортировки. Давайте разберем, как это работает:

1. В начале функции `switched` инициализируется значением 1. Это значение указывает на то, что в процессе сортировки были произведены обмены элементов массива.

2. Перед каждым проходом через внешний цикл сортировки (`for` с переменной `i`), `switched` устанавливается в 0. Это означает, что по умолчанию предполагается, что обмены элементов не производились в текущем проходе.

3. Во внутреннем цикле сортировки (`for` с переменной `j`), сравниваются пары соседних элементов. Если порядок элементов неправильный (то есть, если элемент с меньшим индексом больше элемента с большим индексом), они меняются местами, и переменная `switched` устанавливается в 1, чтобы указать, что произошел обмен.

4. После завершения внутреннего цикла проверяется значение `switched`. Если ни одного обмена не произошло (то есть `switched` осталась равной 0), это означает, что массив уже отсортирован, и дополнительные проходы через внешний цикл не нужны. Поэтому выполнение внешнего цикла останавливается.

Таким образом, использование переменной `switched` позволяет сократить количество проходов по массиву, когда он уже отсортирован, что улучшает производительность алгоритма.

==А также интересное выражение== `for(i = 0; i < size && switched; i++)`:

Выражение `&& switched` в условии `for` проверяет значение переменной `switched` на равенство 0 или 1. В C++, любое значение, отличное от 0, интерпретируется как `true`, а 0 интерпретируется как `false`. 

Таким образом, если `switched` равно 1, то выражение `switched` интерпретируется как `true`, и цикл продолжает выполняться. Если же `switched` равно 0, то выражение `switched` интерпретируется как `false`, и выполнение цикла прекращается.

Такой способ управления циклом позволяет избежать лишних итераций, если на предыдущем проходе не произошло ни одного обмена элементов, что указывает на то, что массив уже отсортирован.

Еще раз отмечу, что данный алгоритм очень неэффективный: общее число сравнений равно `(N-1)N`, то есть если массив состоит из 10 элементов, как у нас, то программа выполнила 90 сравнений, чтобы отсортировать массив. Это настоящее расточительство ресурсов: представьте, что будет, если элементов будет не 10, а одни миллион?! Тем не менее, этот алгоритм часто используется при обучении программированию. Если вы так и не разобрались, как он работает, на страничке в Википедии можно увидеть анимацию, демонстрирующую алгоритм в динамике: https://goo.gl/KGE6yn