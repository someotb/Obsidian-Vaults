Бинарный (он же двоичный) поиск - классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины. Данный метод также известен как метод деления пополам.

Если у нас есть массив, содержащий упорядоченную последовательность данных, то очень эффективен двоичный поиск. Да, вы все правильно поняли, бинарный поиск работает только на уже отсортированных массивах, поэтому перед применением бинарного поиска к произвольному массиву (прочитанному из фала или введенному пользователем), его нужно отсортировать.

Переменные `left` и `right` содержат, соответственно, левую и правую границы отрезка массива, где находится нужный нам элемент. Мы начинаем всегда с исследования среднего элемента отрезка (`middle`). Если искомое значение меньше среднего элемента, мы переходим к поиску в верхней половине отрезка, где все элементы меньше только что проверенного. Другими словами, значением `right` становится (`middle - 1`) и на следующей итерации мы работаем с половиной массива. Таким образом, в результате каждой проверки мы вдвое сужаем область поиска. Так в нашем примере, после первой итерации область поиска - всего лишь 5 элементов.

Двоичный поиск - очень мощный и эффективный метод. Если представить, что длина массива равна 1023, после первого сравнения область сужается до 511 элементов, а после второй - до 255. Легко посчитать, что для поиска в массиве из 1023 элементов достаточно 10 сравнений.

```cpp
#include <iostream>

using namespace std;

#define TRUE 0
#define FALSE 1

int main(void) {
    int array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int left = 0;
    int right = 10;
    int middle = 0;
    int number = 0;
    int bsearch = FALSE;
    int i = 0;
    
    cout << "Массив: ";
    for(int i = 0; i < 10; i++) cout << array[i] << " ";
    cout << "\nИщем число: ";
    cin >> number;

    while(bsearch == FALSE && left <= right) {
        middle = (left + right) / 2;
        if(number == array[middle]) {
            bsearch = TRUE;
            cout << "** Найдено! **\n";
        } else {
            if(number < array[middle]) right = middle -1;
            if(number > array[middle]) left = middle + 1;
        }
    }
    
    if(bsearch == FALSE) cout << "-- Не найдено --\n";

    return 0;
}
```
В принципе тут все понятно. Ничего интересного выделить не получается, так что идем дальше

Прошлый пример показывал, как выполнить поиск по упорядоченному массиву целых чисел. Но на практике чаще возникают задачи поиска определенной строки, нежели определенного числа. Именно поэтому сейчас будет рассмотрен пример двоичного поиска по массиву указателей строк.

Принцип тот же. Исходный массив должен быть отсортирован. В функцию `binsearch` передается массив строк, размер массива и искомое значение. Функция возвращает 0, если значение не найдено или же позицию найденного значения. Учитывая, что массив отсортирован, средняя позиция определяется как сумма начальной и последней (`begin + end`), разделенная на 2. Далее нужно сравнить функцией `strcmp()` искомое слово со словом в получившейся позиции. Функция `strcmp()` возвращает значение.

- < 0, если первый ее аргумент лексикографически меньше, чем второй;
- > 0, если первый аргумент лексикографически больше, чем второй;
- 0, если аргументы равны;

Так вот, функция `strcmp()` не только сравнивает строки, но и еще и подсказывает нам в каком направлении двигаться - в соответствии с этим мы или увеличиваем позицию или уменьшаем ее. Если функция вернула 0, то мы можешь вернуть позицию (переменная `position`), в которой это произошло.

Прототип функции `ctrcmp()` выглядит так:
```cpp
int strcmp(const char *str1, const char *str2)
```

Вот сам код:
```cpp
#include <iostream>
#include <cstring>

using namespace std;

static int binsearch(char *str[], int max, char *value) {
    int position;
    int begin = 0;
    int end = max - 1;
    int cond = 0;

    while(begin <= end) {
        position = (begin + end) / 2;
        if((cond = strcmp(str[position], value)) == 0)
            return position;
        else if(cond < 0)
            begin = position + 1;
        else
            end = position - 1;
    }
    return 0;
}

int main(void) // int main(void) - означает что main не принимает указателей
{
    char *strings[] = {"audi", "bently", "bmw", "cadillac", "ford"};
    int i, asize, result;
    i = asize = result = 0;
    asize = sizeof(strings) / sizeof(strings[0]); // Подсчет кол-ва элементов
    for(i = 0; i < asize; i++) cout << i << " " << strings[i] << endl;
    cout << endl;

    if((result = binsearch(strings, asize, "mercedes")) != 0)
        cout << " 'mercedes' найдено на позиции: " << result << endl;
    else
        cout << " 'mercedes' не найдено..\n";
        
    return 0;

}
```

Функция `strcmp` возвращает целое число, которое имеет следующий смысл:

- Если строка `s1` (первый аргумент) меньше строки `s2` (второй аргумент), функция возвращает значение меньше нуля.
- Если строки `s1` и `s2` идентичны, функция возвращает ноль.
- Если строка `s1` больше строки `s2`, функция возвращает значение больше нуля.

Давайте разберем эту строку:

```cpp
static int binsearch(char *str[], int max, char *value)
```

1. `static`: Это ключевое слово, которое указывает на локальную видимость функции. Когда функция объявлена с ключевым словом `static`, она доступна только в файле, в котором она определена, и не доступна другим файлам в программе. Это означает, что функция `binsearch` может быть использована только в том же файле, где она определена.

2. `int`: Это тип возвращаемого значения функции. Функция `binsearch` возвращает целочисленное значение.

3. `binsearch`: Это имя функции.

4. `char *str[]`: Это аргумент функции, который представляет собой массив указателей на строки. `char *` указывает на тип элементов массива (в данном случае, указателей на строки), а `str[]` указывает на то, что это массив.

5. `int max`: Это аргумент функции, который представляет максимальный размер массива строк.

6. `char *value`: Это аргумент функции, который представляет значение, которое мы ищем в массиве строк.

Таким образом, объявление `static int binsearch(char *str[], int max, char *value)` говорит о том, что `binsearch` является локальной функцией, она возвращает целочисленное значение и принимает три аргумента: массив строк, максимальный размер массива и значение для поиска.