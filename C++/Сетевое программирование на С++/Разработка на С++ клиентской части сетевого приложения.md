Начнем мы с приложения-клиента. Оно будет отправлять серверу случайное число в цикле - при каждой итерации будет отправляться новое число. После отправки этого случайного числа приложение будет читать ответ сервера, выводить его на экран и засыпать на одну секунду.

Работать приложение будет так. У нас есть класс `TCPClient`, объект которого мы создадим в программе. Для подключения к серверу будет использоваться метод `setup()`, которому нужно будет передать два параметра - IP-адрес сервера и нужный порт (сервер должен прослушивать этот порт, поэтому если вы его измените на клиенте, нужно будет изменить и на сервере):

`tcp.setup("127.0.0.1", 11999);`

Метод `send()` используется для отправки строки на сервер. Метод можно вызывать только после установки соединения. В случае успешной установки соединения метод `setup()` возвращает `true`. Мы не производим проверку на установку соединения для упрощения кода примера, но вы можете такую реализовать. Это не сложно.

Получить ответ от сервера можно методом `receive()`. Если у сервера есть ответ, то возвращается непустая строка, которую мы просто выводим на экран с помощью оператора `<<`.

Наш класс `TCPClient` будет описан в заголовочном файле `TCPClient.h`, который мы подключаем инструкцией:

`#include "TCPClient.h"`

Собственно, когда мы знаем, что к чему, мы готовы рассмотреть первый листинг из этого примера - файла `client.cpp`.

Файл `client.cpp`. Приложение-клиент:

```cpp
#include <iostream>
#include <signal.h>
#include "TCPClient.h"

TCPClient tcp; // Наш основнойй класс

// Обработчик выхода из программы
void sig_exit(int s)
{
	tcp.exit(); // Вызов метода exit()
	exit(0);
}

int main(int argc, char *argv[])
{
	// Установка обработчика выходы из программы
	signal(SIGINT, sig_exit);

	tcp.setup("127.0.0.1", 11999);
	while(1)
	{
		srand(time(NULL));
		
		tcp.Send(to_string(rand()%25000));
		string rec = tcp.receive();

		if(rec != "" )
		{
			cout << "Server Responce: " << rec << endl;
		}
		sleep(1);
	}
	return 0;
}
```

В коде ниже приведен заголовочный файл `TCPClient.h`. В нем мы подключаем другие необходимые заголовочные файлы, а также объявляем сам класс и его методы. Реальный код программы будет в третьем файле - `TCPClient.cpp`.

```cpp
#ifndef TCP_CLIENT_H
#define TCP_CLIENT_H

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netdb.h>
#include <vector>

using namespace std;

class TCPClient
{
	private:
		int sock;
		std::string address;
		int port;
		struct sockaddr_in server;
	public:
		TCPClient();
		bool setup(string address, int port);
		bool Send(string data);
		string receive(int size = 4096);
		string read();
		void exit();
};

#endif
```

А ШО по заголовкам:

Этот фрагмент кода представляет собой стандартные директивы препроцессора в языке C++, которые обеспечивают защиту от многократного включения (include guard) и подключают необходимые заголовочные файлы для работы с сокетами в сетевом программировании.

Давайте разберемся подробнее:

1. `#ifndef TCP_CLIENT_H` - Эта директива проверяет, не была ли ранее объявлена метка `TCP_CLIENT_H` в текущем файле или в другом файле, который уже был включен. Если метка не определена, то код между `#ifndef` и соответствующим `#endif` будет включен в обработку компилятором. Это предотвращает многократное включение одного и того же файла.

2. `#define TCP_CLIENT_H` - Если метка `TCP_CLIENT_H` не была определена ранее, эта директива определяет ее. Это предотвращает повторное включение того же файла в процессе компиляции.

3. `#include` - Эти директивы подключают заголовочные файлы, необходимые для работы с сокетами в сетевом программировании. В вашем случае это стандартные заголовочные файлы, такие как `iostream`, `stdio.h`, `stdlib.h` и другие, а также заголовочные файлы, относящиеся к сокетам и сетевым операциям, такие как `sys/socket.h`, `netinet/in.h`, `arpa/inet.h`, `netdb.h` и т.д.

4. `#endif` - Эта директива обозначает конец блока условной компиляции, начатого `#ifndef`. Все кодовые строки между `#ifndef` и `#endif` будут включены в компиляцию только если метка `TCP_CLIENT_H` не была определена ранее.

Таким образом, этот фрагмент кода гарантирует, что заголовочные файлы будут подключены только один раз и не приведут к ошибкам множественного определения переменных или функций при компиляции программы.

Файл `TCPClient.h` мы добавим к нашему проекту уже при компиляции программы - мы укажем его название в опциях компилятора. Файл `TCPClient.cpp` содержит реальный код, поэтому основное внимание нужно уделить именно ему. Начнем с метода `setup()`.

Первым делом нам нужно открыть сокет. Это мы делаем так:

```cpp
if(sock == -1)
{
	sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock == -1)
	{
		cout << "Could not create socket" << endl;
	}
}
```

Член класса `sock` содержит открытый сокет. Если сокет не открыт, то его значение будет равно -1. Это и есть значение по умолчанию, заданное в конструкторе класса:

```cpp
TCPClient::TCPClient()
{
	sock = -1;
	port = 0;
	address = "";
}
```

Для подключения к серверу сначала нудно заполнить структуру `server`:

```cpp
struct sockaddr_in server
```

Мы должны указать адрес сервера, протокол и порт сервера соответственно:

```cpp
sever.sin_addr.s_addr = inet_addr(address.s_str());
server.sin_family = AF_INET;
server.sin_port = htons(port);
```

После того, как структура `srver` заполнена мы можем использовать функцию `connect()` для подключения к серверу. Этой функции нужно передать наш сокет, структуру `server` и размер этой структуры:

```cpp
if (connect(sock, (struct sockaddr *) &server, sizeof(server)) < 0)
{
	perror("connect failed. Error");
	return false;
}
return true;
```

Если функция `connect()` вернула значение меньше 0, то подключиться к серверу не получилось.

В принципе все понятно. Полный код метода `setup()` будет приведен ниже. Далее переходим к методу `Send()`. Нам нужно использовать одноимённую функцию `send()`, указав сокет, передаваемые данные и длину этих данных:

```cpp
if (send(sock, data.c_str(), strlen(data.c_str()), 0) < 0)
{
	cout << "Send failed: " << data << endl;
	return false;
}
```

Метод `read()` позволяет получить ответ от сервера. Для чтения данных мы будем использовать метод `recv`. Читать данные будем в массив `buffer`. Чтение будет происходить посимвольно, а как прочитаем последний байт (когда встретим символ `\n`) мы вернем полученную строку `reply`:

```cpp
char buffer[1] = {}; // Буфер
string reply; // Результат
while (buffer[0] != '\n') {
	if (recv(sock, buffer, sizeof(buffer), 0) < 0)
	{
		cout << "Receive failed!" << endl;
		retunr nullptr;
	}
	// Добавляем каждый прочиатнный символ к reply
	reply += buffer[0];
}
return reply; // Возвращаем результат
```

Кроме метода `read()` у нас есть еще метод `receive()`, который делает все то же самое, но немного иначе. Здесь у нас будет не посимвольное чтение, а чтение строки определённого размера `size`:

```cpp
string TCPClient::receive(int size)
{
	char buffer[size];
	numset(&buffer[0], 0, sizeof(buffer));

	string reply;
	if( recv(sock, buffer, size, 0) < 0)
	{
		cout << "Receive failed!" << endl;
		return nullptr;
	}
	buffer[size-1] = '\0';
	reply = buffer;
	return reply;
}
```

Какой метод использовать, решайте сами. Для примера проще использовать метод `receive()`, в реальной жизни, где ответ сервера не имеет фиксированного размера - метод `read()`.

Метод `exit()` закрывает сокет:

```cpp
close (sock);
```

Полный код `TCPClient.cpp` приведен ниже:

```cpp
#include "TCPClient.h"

TCPClient::TCPClient()
{
	sock = -1;
	port = 0;
	address = "";
}

bool TCPClient::setup(string address, int port)
{
	if(sock == -1)
	{
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if(sock == -1)
		{
			cout << "Could not create socket" << endl;
		}
	}
	if(inet_addr(address.c_str()) == -1)
	{
		struct hostent *he;
		struct in_addr **addr_list;
		if((he == gethostbyname(address.c_str())) == NULL)
		{
			herror("gethostbyname");
			cout << "Failed to resolve hostname\n";
			return false;
		}
		addr_list = (struct in_addr **) he->h_addr_list;
		for(int i = 0; addr_list[i] != NULL; i++)
		{
			server.sin_addr = *addr_list[i];
			break;
		}
	}
	else
	{
		server.sin_addr.s_addr = inet_addr(address.c_str());
	}
	server.sin_family = AF_INET;
	server.sin_port = htons(port);
	if(connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
	{
		perror("Connect failed. Error");
		return false;
	}
	return true;
}

bool TCPClient::Send(string data)
{
	if(sock != -1)
	{
		if(send(sock, data.c_str(), strlen(data.c_str()), 0) < 0)
		{
			cout << "Send failed: " << data << endl;
			return false;
		}
	}
	else
		return false;
	return true;
}

string TCPClient::receive(int size)
{
	char buffer[size];
	memset(&buffer[0], 0, sizeof(buffer));

	string reply;
	if(recv(sock, buffer, size, 0) < 0)
	{
		cout << "Receive failed!" << endl;
		return nullptr;
	}
	buffer[size-1] = '\n';
	reply = buffer;
	return reply;
}

string TCPClient::read()
{
	char buffer[1] = {};
	string reply;
	while(buffer[0] != '\n')
	{
		if(recv(sock, buffer, sizeof(buffer), 0) < 0)
		{
			cout << "Receive failed!" << endl;
			return nullptr;
		}
		reply += buffer[0];
	}
	return reply;
}

void TCPClient::exit()
{
	close(sock);
}
```

Короче, это пиздец, я слишком мал для этого, сейчас я даже не могу скомпилировать проект, и вообще почему автор показывает как компилировать проект в самом конце нахуй, чо за бред бля, ладно...
Надеюсь я сюда вернусь и разберусь с этим говном. А пока пойду изучать следующую и по совместительству последнюю главу.