ЭЭЭЭ
я еьао
короче, ну это такая хуяня которую можно передававать как значение, чисто переносчик того что ты в нее положишь, но я пока не понял чем она отличается от обычной перменной, он ничего не возвращает и ваще у меня в голове каша, вот пример кода на питоне:
```python
def do_smth(action):
	x = 53
	action(x)
	
do_smth(lambda x: print(f"Number is: {x}"))

a = [1, 2, 5, 5, 6, 1, 12, 132, 354, 54, 32, 32, 3, 12, 32, 3, 1]
new_a = list(map(lambda x: x**2, a)) # Здесь с помощью безымянной lambda-функции мы каждый элемент списка a возводим во 2 степень
print(new_a)

  
summa = reduce((lambda x, y: x + y), a) # Здесь мы с помощью reduce и lambda-функции суммируем элементы списка
summa1 = sum(a)
print(f"Сумма всех элементов через reduce: {summa} и через sum: {summa1}")
```

В Kotlin она работает так:
```kotlin
{ DeviceData ->
	if (DeviceData != null) {
		// do something
	} eles {
		println("Error to get data")
	}
} 
```

-  { ... } - тело лямбды 
-  "->" все что идет после этих символов выполняется когда будет вызван [[Callback|callback]]

#### Кстати, если функция принимает в себя лямбда выражение(функцию), то такая функция называется функцией высшего порядка


```kotlin
fun main() {
	val x = 4
	val y = 2
	val operation = {val1: Int, val2: Int -> val1 * val2}
	calculate(x,y,operation)
}

def calculate(x: Int. y: Int, operation: (v1: Int, v2: Int) -> Int) {
	println(oprtation(x,y))
}

// calculate - функция высшего порядка
```

Если лямбда выражение указано последним, то можно ее вынести из круглых скобок в фигурные. Пример:
```kotlin
fun main() {
	val x = 4
	val y = 2
	val operation = {val1: Int, val2: Int -> val1 * val2}
	calculate(x,y,operation)
	calculate(4, 5){val1, val2 -> val1 * val2} // Вот так
	calculate(25, 100){val1, val2 -> val2 - val1} // Или так
}

def calculate(x: Int. y: Int, operation: (v1: Int, v2: Int) -> Int) {
	println(oprtation(x,y))
}
```

Функция может вернуть лямбду в качестве результата
```kotlin
fun main() {
	calculate(10, 15, GetOperation("multiply")) // Будет 10 * 15 = 150
}

def calculate(x: Int. y: Int, operation: (v1: Int, v2: Int) -> Int) {
	println(oprtation(x,y))
}

def GetOperation(operation: String): (Int, Int) -> Int {
	return when(operation) {
	"add" -> {x:Int, y:Int -> x + y}
	"multiply" -> {x: Int, y: Int -> x * y}
	else -> {_,_ -> 0} // Названия аргументов нам не важны, мы ставим прочерки
	} 
}
```

Если нужно поставить готовую функцию из класса, тогда:

```kotlin
class Calc {
	fun add(x:Int, y:Int) = x + y
}

fun main() {
	calculate(14, 154, Calc()::add)
}

def calculate(x: Int, y: Int, operation: (v1: Int, v2: Int) -> Int){
	println(operation(x, y))
}
```

Использование лямбды вместе с let:
```kotlin
int main() {
	val person: Person? = Person("Кирилл")
	val name = person?.let { it.name.toUpperCase() } ?: "Нет имени"
	println(name)
}

class Person(val name: String)
```

В данном случае лямбда представляется объектом "it", это объект на который вызывается наша лямбда, в нашем случае это объект типа Person, а именно "name"